# inline

```c++

class A
{
public:
    void f1(int x); 

    /**
     * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。
     *
     * @param x
     * @param y
     */
    void Foo(int x,int y) ///< 定义即隐式内联函数！
    {
    
    };
    void f1(int x); ///< 声明后，要想成为内联函数，必须在定义处加inline关键字。  
};

```

- 如果执行函数体内代码的时间相比于函数调用的开销较大，那么效率的收货会更少！
- 另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

以下情况不宜用内联：

（1）如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高。

（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。

2.虚函数（virtual）可以是内联函数（inline）吗？

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

# sizeof

- 空类的大小为1字节
- 一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。
- 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。
- 普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小
- 虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！
- 虚继承,继承基类的vptr。

**对齐的四个概念值** https://www.cnblogs.com/clover-toeic/p/3853132.html
1）**数据类型自身的对齐值：**就是上面交代的基本数据类型的自身对齐值。
2）**指定对齐值：**#pragma pack (value)时的指定对齐值value。 
3）**结构体或者类的自身对齐值：**其数据成员中自身对齐值最大的那个值。 
4）**数据成员、结构体和类的有效对齐值：**自身对齐值和指定对齐值中小的那个值。

   结构体字节对齐的细节和具体编译器实现相关，但一般而言满足三个准则：

   1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；

   2) 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；

   3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。

# 纯虚函数

- 纯虚函数：没有函数体的虚函数
- 抽象类：包含纯虚函数的类